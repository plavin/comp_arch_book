Phase Attribution
=================

Once we have performed phase analysis, the natrual question is "What do these phases correspond to in the source?"
This is the problem of *Phase Attribution*. In working set based phase analysis schemes such as ours, this is 
easy to define, as we need only look at which program counters get assigned to each phase. 

But how do we figure out what those program counters (PCs) correspond to? We can use debugging information
generated by C and C++ compilers, which is in the [DWARF](http://dwarfstd.org/) format on Linux[^v4]. The standard itself

is somewhat long, so we'll include just enough info here to understand how we take the PCs from a phase and attribute 
them to some function.

[^v4]: This guide was written using the DWARF 4 standard. While DWARF 5 is available, it is not yet the default for gcc, and 
is not supported by the python library pyelftools, which we use for our project. 

If you want to skip the explanation here and start playing with it, you can view this algorithm implemented on Github [here](https://github.com/plavin/ModelSwapping/blob/master/DWARFMap.py). It is part of the larger project but the linked python file can be run by itself.

Ok, let's get to the explanation.

## The Debugging Information Entry
The Debugging Information Entry (DIE) is the basic building block of the DWARF format. Each one gets an an identifying tag (or type) and a set of attributes. 
The tags all have names that look like `DW_TAG_*`, and the attributes are named `DW_AT_*`.

### Important Tags and Attributes

Let's take a look at the tags that we need to know to parse the DWARF with the pyelftools library, as well as some associated attributes.

* `DW_TAG_compile_unit`: This tag indicates that the DIE represents a complete compilation unit, such as a single `.o` file. You can expect to find one for each source file in your executable. 
* `DW_TAG_subprogram`: This tag is for DIEs that represent a function (or subroutine). We are concerned with the following attributes that are used with this tag:
    * `DW_AT_name`: The name of the function, such as `main`. 
    * `DW_AT_low_pc`: The base PC of the function. This may not be present (and if it isn't, then the high PC will also not exist) in the case of a subroutine that is not actually implemented at this location. For instance, the DIE may describe a function that is only ever used in an inline fashion. In such cases we will only be concerned with the name attribute, as we will get the PC range elsewhere. 
    * `DW_AT_high_pc`: This is either an offset from the low PC, or the high PC itself. You will need to inspect further to determine which is which, but it seems gcc typically generates an offset.
* `DW_TAG_inlined_subroutine`: DIEs with this tag are generated for inlined subroutines. They will be generated at children of DIEs with the `DW_TAG_subprogram`. They will not have a `DW_AT_name` attribute, but they will have high and low PCs. These PCs will be a subset of the DIE that is the parent of this one.
    * `DW_AT_abstract_origin`: This is a reference to a DIE that contains the prototype of this subroutine. This is how we get the name of this function.

## Parsing DWARF Information with `pyelftools`

We will be using python to parse the DWARF information contained in executables. The [`pyelftools`](https://github.com/eliben/pyelftools) library allows us to do with with DWARF files up to DWARF 4. You can install this package with `pip install pyelftools` or `conda install pyelftools`.

### The Basic Algorithm

I won't go over the finer details, but I will explain the basic algorithm that our code uses[^algo]. We can first iterate over the Compilation Units by using the `dwarfinfo.iter_CUs()`. Once we have a single CU, we can iterate over all the DIEs it contains (which will correspond to all the functions defined within that file). Iterating over DIEs in a CU is done by calling the CU's `iter_DIEs()` method.

Once we are iterating over DIEs, we'll look at all of the ones tagged either `DW_TAG_subprogram` or `DW_TAG_inlined_subroutine`. We will then record all these ranges, and store them in a hierarcical data structure so that we can search through these ranges later. 

When it is time to actually determine which range a PC belongs to, we will search over all the ranges we have identified. Once we find one, we need to recursively search within that range to see if the PC was actually part of an inlined function. 

[^algo]: I picked up the basics of this algorithm from [Sy Brand's Blog.](https://web.archive.org/web/20200420073800/https://blog.tartanllama.xyz/writing-a-linux-debugger-elf-dwarf/) Scroll down to "Which function am I in?"

### Example Run

Let's look at the data structure produced by this algorithm when run on a simple executable. Here is the code:

```
int main (int argv, char ** argc)
{
    int sz = 25;
    double *c = (double*)malloc(sizeof(double) * sz);
    double *d = (double*)malloc(sizeof(double) * sz);
    double *e = (double*)malloc(sizeof(double) * sz);
    double *f = (double*)malloc(sizeof(double) * sz);

   for (int i = 0; i < sz; i++) {
       c[i] = i * i;
       d[i] = i + i;
   }

   vadd(e, c, d, sz);
   vmul(f, c, d, sz);

   printf("Result: %.2f\n", e[2]*f[3]);
}
```

The functions `vadd` and `vmul` perform elementwise vector addition and multiplication respectively. I haven't included their defintion here as it can be done in two different ways, producing two different results. 

If they are defined in a separate file, it is unlikely they will be inlined. This means each function will be mapped into its own range in the address space. Below, you'll see that the top level is labeled "unkown". This is our catch all, so that every address will get some name when we query this data structure. Many PCs that occur when executing will fall into this range, because there are many parts of our executable that we do not have DWARF information for, such as external libraries. 

```
unknown [0x0 - 0xffffffffffffffff]
  ↳ main [0x400a1d - 0x400b96]
  ↳ vadd [0x400b96 - 0x400c0e]
  ↳ vmul [0x400c0e - 0x400c86]
```

If `vadd` and `vmul` are defined in the same file, they may be inlined. If they do get inlined by the compiler, they will appear as sub-ranges of main instead of having non-overlapping ranges as above. This is represented by indentation in the output below.

```
unknown [0x0 - 0xffffffffffffffff]
  ↳ main [0x400a1d - 0x400c8b]
    ↳ vadd [0x400b75 - 0x400bf6]
    ↳ vmul [0x400bf6 - 0x400c59]
```
